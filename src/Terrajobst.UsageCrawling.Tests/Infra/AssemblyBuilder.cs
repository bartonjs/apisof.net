using System.Reflection.PortableExecutable;
using Basic.Reference.Assemblies;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace Terrajobst.UsageCrawling.Tests.Infra;

public sealed class AssemblyBuilder
{
    private readonly List<CSharpCompilation> _dependencies = new();
    private CSharpCompilation? _assembly;

    public AssemblyBuilder SetAssembly(
        string source,
        TargetFramework framework = TargetFramework.Net80,
        Func<CSharpCompilation, CSharpCompilation>? transformer = null
        )
    {
        var compilation = CreateCompilation(source, framework);

        if (transformer is not null)
            compilation = transformer(compilation);

        _assembly = compilation;
        return this;
    }

    public AssemblyBuilder AddDependency(string source, TargetFramework framework = TargetFramework.Net80)
    {
        var compilation = CreateCompilation(source, framework);
        _dependencies.Add(compilation);
        return this;
    }

    private (MemoryStream PEStream, CSharpCompilation Compilation) ToStream()
    {
        if (_assembly is null)
            throw new InvalidOperationException("No assembly set");

        var dependencyReferences = _dependencies.Select(c => c.ToMetadataReference());
        var compilation = _assembly.AddReferences(dependencyReferences);

        var peStream = new MemoryStream();
        var result = compilation.Emit(peStream);
        if (!result.Success)
        {
            var diagnostics = string.Join(Environment.NewLine, result.Diagnostics);
            var message = $"Compilation has errors{Environment.NewLine}{diagnostics}";
            throw new Exception(message);
        }

        peStream.Position = 0;
        return (peStream, compilation);
    }

    public PEReader ToPEReader()
    {
        var (peStream, _) = ToStream();
        return new PEReader(peStream, PEStreamOptions.Default);
    }

    private static CSharpCompilation CreateCompilation(string source, TargetFramework framework)
    {
        var options = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary,
                                                   optimizationLevel: OptimizationLevel.Release);
        var references = GetReferences(framework);
        var compilation = CSharpCompilation.Create("dummy",
                                                   [CSharpSyntaxTree.ParseText(source)],
                                                   references,
                                                   options);
        return compilation;
    }

    private static IEnumerable<MetadataReference> GetReferences(TargetFramework framework)
    {
        return framework switch
        {
            TargetFramework.Net80 => Net80.References.All,
            TargetFramework.Net472 => Net472.References.All,
            TargetFramework.NetStandard20 => NetStandard20.References.All,
            TargetFramework.NetStandard13 => NetStandard13.References.All,
            TargetFramework.NetCoreApp31 => NetCoreApp31.References.All,
            _ => throw new ArgumentOutOfRangeException(nameof(framework), framework, null)
        };
    }

    public static bool IsAutoGenerated(string documentationId)
    {
        ThrowIfNull(documentationId);

        return AutoGeneratedKeys.Contains(documentationId);
    }

    private static readonly SortedSet<string> AutoGeneratedKeys = [
        "T:System.Runtime.CompilerServices.CompilerGeneratedAttribute",
        "M:System.Runtime.CompilerServices.CompilerGeneratedAttribute.#ctor",
        "T:System.Runtime.CompilerServices.CompilationRelaxationsAttribute",
        "M:System.Runtime.CompilerServices.CompilationRelaxationsAttribute.#ctor(System.Int32)",
        "T:System.Runtime.CompilerServices.RuntimeCompatibilityAttribute",
        "M:System.Runtime.CompilerServices.RuntimeCompatibilityAttribute.#ctor",
        "F:System.Runtime.CompilerServices.RuntimeCompatibilityAttribute.WrapNonExceptionThrows",
        "P:System.Runtime.CompilerServices.RuntimeCompatibilityAttribute.WrapNonExceptionThrows",
        "T:System.Runtime.CompilerServices.RefSafetyRulesAttribute",
        "M:System.Runtime.CompilerServices.RefSafetyRulesAttribute.#ctor(System.Int32)",
        "T:System.Diagnostics.DebuggableAttribute",
        "T:System.Diagnostics.DebuggableAttribute.DebuggingModes",
        "M:System.Diagnostics.DebuggableAttribute.#ctor(System.Diagnostics.DebuggableAttribute.DebuggingModes)",
        "T:System.Void",
        "T:System.Object",
        "T:System.Int32",
    ];
}